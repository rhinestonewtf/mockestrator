// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

export const zPostIntentsCostData = z.object({
    body: z.optional(z.object({
        destinationChainId: z.number().gte(0),
        tokenTransfers: z.array(z.object({
            tokenAddress: z.string(),
            amount: z.optional(z.coerce.bigint())
        })),
        account: z.object({
            address: z.string(),
            accountType: z.string(),
            setupOps: z.optional(z.array(z.object({
                to: z.string(),
                data: z.string().regex(/^0x[a-fA-F0-9]*$/)
            }))),
            emissaryConfig: z.optional(z.object({
                configId: z.number().lte(255),
                validatorAddress: z.string(),
                emissaryAddress: z.string(),
                emissaryEnable: z.object({
                    allocatorSig: z.string().regex(/^0x[a-fA-F0-9]*$/),
                    userSig: z.string().regex(/^0x[a-fA-F0-9]*$/),
                    expires: z.coerce.bigint(),
                    nonce: z.coerce.bigint(),
                    allChainIds: z.unknown(),
                    chainIndex: z.coerce.bigint()
                }),
                emissaryConfig: z.object({
                    allocator: z.optional(z.string()).default('0x1fcaa96c3aa5bbb0af8d89211cc8954c170d5903'),
                    scope: z.optional(z.number()).default(0),
                    resetPeriod: z.optional(z.number()).default(6),
                    validator: z.string(),
                    validatorConfig: z.string().regex(/^0x[a-fA-F0-9]*$/)
                })
            })),
            delegations: z.optional(z.record(z.string(), z.object({
                contract: z.string()
            })))
        }),
        destinationExecutions: z.optional(z.array(z.object({
            to: z.string(),
            value: z.coerce.bigint(),
            data: z.string().regex(/^0x[a-fA-F0-9]*$/)
        }))),
        destinationGasUnits: z.optional(z.coerce.bigint()),
        accountAccessList: z.optional(z.union([
            z.array(z.object({
                chainId: z.number().gte(0),
                tokenAddress: z.string()
            })),
            z.object({
                chainIds: z.optional(z.array(z.number().gte(0))),
                tokens: z.optional(z.array(z.string())),
                chainTokens: z.optional(z.record(z.string(), z.array(z.string()))),
                exclude: z.optional(z.object({
                    chainIds: z.optional(z.array(z.number().gte(0))),
                    tokens: z.optional(z.array(z.string())),
                    chainTokens: z.optional(z.record(z.string(), z.array(z.string())))
                }))
            })
        ])),
        options: z.object({
            topupCompact: z.optional(z.boolean()).default(false),
            settlementLayers: z.optional(z.array(z.enum([
                'ACROSS',
                'ECO',
                'RELAY'
            ]))),
            sponsorSettings: z.optional(z.object({
                gasSponsored: z.optional(z.boolean()).default(false),
                bridgeFeesSponsored: z.optional(z.boolean()).default(false),
                swapFeesSponsored: z.optional(z.boolean()).default(false)
            })),
            feeToken: z.optional(z.enum([
                'ETH',
                'WETH',
                'USDC',
                'USDT',
                'POL',
                'WPOL',
                'S',
                'WS'
            ]))
        })
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'x-api-key': z.string()
    })
});

/**
 * Successfully retrieved the order path
 */
export const zPostIntentsCostResponse = z.union([
    z.object({
        hasFulfilledAll: z.literal(true),
        tokensSpent: z.record(z.string(), z.record(z.string(), z.object({
            locked: z.coerce.bigint(),
            unlocked: z.coerce.bigint()
        }))),
        tokensReceived: z.array(z.object({
            tokenAddress: z.string(),
            amountSpent: z.coerce.bigint(),
            targetAmount: z.coerce.bigint(),
            fee: z.coerce.bigint(),
            hasFulfilled: z.boolean()
        }))
    }),
    z.object({
        hasFulfilledAll: z.literal(false),
        tokenShortfall: z.array(z.object({
            tokenAddress: z.string(),
            destinationAmount: z.coerce.bigint(),
            amountSpent: z.coerce.bigint(),
            fee: z.coerce.bigint(),
            tokenSymbol: z.string(),
            tokenDecimals: z.number().gte(0)
        })),
        totalTokenShortfallInUSD: z.number().gte(0)
    })
]);

export const zPostIntentsRouteData = z.object({
    body: z.optional(z.object({
        destinationChainId: z.number().gte(0),
        tokenTransfers: z.array(z.object({
            tokenAddress: z.string(),
            amount: z.coerce.bigint()
        })),
        account: z.object({
            address: z.string(),
            accountType: z.string(),
            setupOps: z.optional(z.array(z.object({
                to: z.string(),
                data: z.string().regex(/^0x[a-fA-F0-9]*$/)
            }))),
            emissaryConfig: z.optional(z.object({
                configId: z.number().lte(255),
                validatorAddress: z.string(),
                emissaryAddress: z.string(),
                emissaryEnable: z.object({
                    allocatorSig: z.string().regex(/^0x[a-fA-F0-9]*$/),
                    userSig: z.string().regex(/^0x[a-fA-F0-9]*$/),
                    expires: z.coerce.bigint(),
                    nonce: z.coerce.bigint(),
                    allChainIds: z.unknown(),
                    chainIndex: z.coerce.bigint()
                }),
                emissaryConfig: z.object({
                    allocator: z.optional(z.string()).default('0x1fcaa96c3aa5bbb0af8d89211cc8954c170d5903'),
                    scope: z.optional(z.number()).default(0),
                    resetPeriod: z.optional(z.number()).default(6),
                    validator: z.string(),
                    validatorConfig: z.string().regex(/^0x[a-fA-F0-9]*$/)
                })
            })),
            delegations: z.optional(z.record(z.string(), z.object({
                contract: z.string()
            })))
        }),
        destinationExecutions: z.optional(z.array(z.object({
            to: z.string(),
            value: z.coerce.bigint(),
            data: z.string().regex(/^0x[a-fA-F0-9]*$/)
        }))),
        destinationGasUnits: z.optional(z.coerce.bigint()),
        accountAccessList: z.optional(z.union([
            z.array(z.object({
                chainId: z.number().gte(0),
                tokenAddress: z.string()
            })),
            z.object({
                chainIds: z.optional(z.array(z.number().gte(0))),
                tokens: z.optional(z.array(z.string())),
                chainTokens: z.optional(z.record(z.string(), z.array(z.string()))),
                exclude: z.optional(z.object({
                    chainIds: z.optional(z.array(z.number().gte(0))),
                    tokens: z.optional(z.array(z.string())),
                    chainTokens: z.optional(z.record(z.string(), z.array(z.string())))
                }))
            })
        ])),
        options: z.optional(z.object({
            topupCompact: z.optional(z.boolean()).default(false),
            settlementLayers: z.optional(z.array(z.enum([
                'ACROSS',
                'ECO',
                'RELAY'
            ]))),
            sponsorSettings: z.optional(z.object({
                gasSponsored: z.optional(z.boolean()).default(false),
                bridgeFeesSponsored: z.optional(z.boolean()).default(false),
                swapFeesSponsored: z.optional(z.boolean()).default(false)
            })),
            feeToken: z.optional(z.enum([
                'ETH',
                'WETH',
                'USDC',
                'USDT',
                'POL',
                'WPOL',
                'S',
                'WS'
            ]))
        }))
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'x-api-key': z.string()
    })
});

/**
 * Successfully retrieved the route
 */
export const zPostIntentsRouteResponse = z.object({
    intentOp: z.object({
        sponsor: z.string(),
        nonce: z.coerce.bigint(),
        expires: z.coerce.bigint(),
        elements: z.array(z.object({
            arbiter: z.string(),
            chainId: z.coerce.bigint(),
            idsAndAmounts: z.unknown(),
            spendTokens: z.unknown(),
            mandate: z.object({
                recipient: z.string(),
                tokenOut: z.unknown(),
                destinationChainId: z.coerce.bigint(),
                fillDeadline: z.coerce.bigint(),
                preClaimOps: z.unknown(),
                destinationOps: z.unknown(),
                qualifier: z.object({
                    settlementContext: z.object({
                        settlementLayer: z.enum([
                            'INTENT_EXECUTOR',
                            'SAME_CHAIN',
                            'ACROSS',
                            'ECO',
                            'RELAY'
                        ]),
                        usingJIT: z.optional(z.boolean()),
                        using7579: z.optional(z.boolean()),
                        requestId: z.optional(z.string())
                    }),
                    encodedVal: z.string().regex(/^0x[a-fA-F0-9]*$/)
                }),
                v: z.number(),
                minGas: z.coerce.bigint()
            }),
            beforeFill: z.optional(z.boolean())
        })),
        serverSignature: z.string().regex(/^[0-9a-f]{64}$/),
        signedMetadata: z.object({
            fees: z.optional(z.object({
                protocolFees: z.optional(z.record(z.string(), z.coerce.bigint())),
                sponsorFee: z.optional(z.object({
                    relayer: z.optional(z.number()),
                    protocol: z.optional(z.number())
                }))
            })),
            tokenPrices: z.record(z.string(), z.number()),
            gasPrices: z.record(z.string(), z.coerce.bigint()),
            opGasParams: z.optional(z.unknown()),
            account: z.object({
                address: z.string(),
                accountType: z.string(),
                setupOps: z.optional(z.array(z.object({
                    to: z.string(),
                    data: z.string().regex(/^0x[a-fA-F0-9]*$/)
                }))),
                emissaryConfig: z.optional(z.object({
                    configId: z.number().lte(255),
                    validatorAddress: z.string(),
                    emissaryAddress: z.string(),
                    emissaryEnable: z.object({
                        allocatorSig: z.string().regex(/^0x[a-fA-F0-9]*$/),
                        userSig: z.string().regex(/^0x[a-fA-F0-9]*$/),
                        expires: z.coerce.bigint(),
                        nonce: z.coerce.bigint(),
                        allChainIds: z.unknown(),
                        chainIndex: z.coerce.bigint()
                    }),
                    emissaryConfig: z.object({
                        allocator: z.optional(z.string()).default('0x1fcaa96c3aa5bbb0af8d89211cc8954c170d5903'),
                        scope: z.optional(z.number()).default(0),
                        resetPeriod: z.optional(z.number()).default(6),
                        validator: z.string(),
                        validatorConfig: z.string().regex(/^0x[a-fA-F0-9]*$/)
                    })
                })),
                accountContext: z.record(z.string(), z.union([
                    z.object({
                        accountType: z.enum([
                            'eoa'
                        ])
                    }),
                    z.object({
                        accountType: z.enum([
                            'smartAccount'
                        ]),
                        isDeployed: z.boolean(),
                        isERC7579: z.boolean(),
                        erc7579AccountType: z.optional(z.enum([
                            'Safe',
                            'Kernel',
                            'Nexus',
                            'Prime'
                        ])),
                        erc7579AccountVersion: z.optional(z.string())
                    })
                ])),
                requiredDelegations: z.optional(z.record(z.string(), z.object({
                    contract: z.string()
                })))
            }),
            quotes: z.optional(z.unknown())
        }),
        signedAuthorizations: z.optional(z.array(z.object({
            chainId: z.number(),
            address: z.string(),
            nonce: z.number(),
            yParity: z.number(),
            r: z.string().regex(/^0x[a-fA-F0-9]*$/),
            s: z.string().regex(/^0x[a-fA-F0-9]*$/)
        })))
    }),
    intentCost: z.object({
        tokensSpent: z.record(z.string(), z.record(z.string(), z.object({
            locked: z.coerce.bigint(),
            unlocked: z.coerce.bigint()
        }))),
        tokensReceived: z.array(z.object({
            tokenAddress: z.string(),
            amountSpent: z.coerce.bigint(),
            targetAmount: z.coerce.bigint(),
            fee: z.coerce.bigint(),
            hasFulfilled: z.boolean()
        }))
    })
});

export const zPostIntentOperationsData = z.object({
    body: z.optional(z.object({
        signedIntentOp: z.object({
            sponsor: z.string(),
            nonce: z.coerce.bigint(),
            expires: z.coerce.bigint(),
            elements: z.array(z.object({
                arbiter: z.string(),
                chainId: z.coerce.bigint(),
                idsAndAmounts: z.unknown(),
                spendTokens: z.unknown(),
                mandate: z.object({
                    recipient: z.string(),
                    tokenOut: z.unknown(),
                    destinationChainId: z.coerce.bigint(),
                    fillDeadline: z.coerce.bigint(),
                    preClaimOps: z.unknown(),
                    destinationOps: z.unknown(),
                    qualifier: z.object({
                        settlementContext: z.object({
                            settlementLayer: z.enum([
                                'INTENT_EXECUTOR',
                                'SAME_CHAIN',
                                'ACROSS',
                                'ECO',
                                'RELAY'
                            ]),
                            usingJIT: z.optional(z.boolean()),
                            using7579: z.optional(z.boolean()),
                            requestId: z.optional(z.string())
                        }),
                        encodedVal: z.string().regex(/^0x[a-fA-F0-9]*$/)
                    }),
                    v: z.number(),
                    minGas: z.coerce.bigint()
                }),
                beforeFill: z.optional(z.boolean())
            })),
            serverSignature: z.string().regex(/^[0-9a-f]{64}$/),
            signedMetadata: z.object({
                fees: z.optional(z.object({
                    protocolFees: z.optional(z.record(z.string(), z.coerce.bigint())),
                    sponsorFee: z.optional(z.object({
                        relayer: z.optional(z.number()),
                        protocol: z.optional(z.number())
                    }))
                })),
                tokenPrices: z.record(z.string(), z.number()),
                gasPrices: z.record(z.string(), z.coerce.bigint()),
                opGasParams: z.optional(z.unknown()),
                account: z.object({
                    address: z.string(),
                    accountType: z.string(),
                    setupOps: z.optional(z.array(z.object({
                        to: z.string(),
                        data: z.string().regex(/^0x[a-fA-F0-9]*$/)
                    }))),
                    emissaryConfig: z.optional(z.object({
                        configId: z.number().lte(255),
                        validatorAddress: z.string(),
                        emissaryAddress: z.string(),
                        emissaryEnable: z.object({
                            allocatorSig: z.string().regex(/^0x[a-fA-F0-9]*$/),
                            userSig: z.string().regex(/^0x[a-fA-F0-9]*$/),
                            expires: z.coerce.bigint(),
                            nonce: z.coerce.bigint(),
                            allChainIds: z.unknown(),
                            chainIndex: z.coerce.bigint()
                        }),
                        emissaryConfig: z.object({
                            allocator: z.optional(z.string()).default('0x1fcaa96c3aa5bbb0af8d89211cc8954c170d5903'),
                            scope: z.optional(z.number()).default(0),
                            resetPeriod: z.optional(z.number()).default(6),
                            validator: z.string(),
                            validatorConfig: z.string().regex(/^0x[a-fA-F0-9]*$/)
                        })
                    })),
                    accountContext: z.record(z.string(), z.union([
                        z.object({
                            accountType: z.enum([
                                'eoa'
                            ])
                        }),
                        z.object({
                            accountType: z.enum([
                                'smartAccount'
                            ]),
                            isDeployed: z.boolean(),
                            isERC7579: z.boolean(),
                            erc7579AccountType: z.optional(z.enum([
                                'Safe',
                                'Kernel',
                                'Nexus',
                                'Prime'
                            ])),
                            erc7579AccountVersion: z.optional(z.string())
                        })
                    ])),
                    requiredDelegations: z.optional(z.record(z.string(), z.object({
                        contract: z.string()
                    })))
                }),
                quotes: z.optional(z.unknown())
            }),
            signedAuthorizations: z.optional(z.array(z.object({
                chainId: z.number(),
                address: z.string(),
                nonce: z.number(),
                yParity: z.number(),
                r: z.string().regex(/^0x[a-fA-F0-9]*$/),
                s: z.string().regex(/^0x[a-fA-F0-9]*$/)
            }))),
            destinationSignature: z.string().regex(/^0x[a-fA-F0-9]*$/),
            originSignatures: z.array(z.string().regex(/^0x[a-fA-F0-9]*$/)),
            options: z.optional(z.object({
                dryRun: z.optional(z.boolean())
            }))
        })
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'x-api-key': z.string()
    })
});

/**
 * Intent operations submitted successfully
 */
export const zPostIntentOperationsResponse = z.object({
    result: z.union([
        z.object({
            id: z.coerce.bigint(),
            status: z.enum([
                'PENDING'
            ])
        }),
        z.object({
            id: z.coerce.bigint(),
            status: z.enum([
                'FAILED'
            ]),
            error: z.union([
                z.object({
                    success: z.literal(true),
                    chainId: z.number().gte(0),
                    gasEstimation: z.string()
                }),
                z.object({
                    success: z.literal(false),
                    call: z.object({
                        to: z.string(),
                        value: z.coerce.bigint(),
                        data: z.string().regex(/^0x[a-fA-F0-9]*$/),
                        chainId: z.number().gte(0)
                    }),
                    details: z.object({
                        blockNumber: z.coerce.bigint(),
                        relayer: z.string(),
                        simulationUrl: z.optional(z.string())
                    })
                })
            ])
        }),
        z.object({
            id: z.coerce.bigint(),
            status: z.enum([
                'FAILED'
            ]),
            simulations: z.array(z.union([
                z.object({
                    success: z.literal(true),
                    chainId: z.number().gte(0),
                    gasEstimation: z.string()
                }),
                z.object({
                    success: z.literal(false),
                    call: z.object({
                        to: z.string(),
                        value: z.coerce.bigint(),
                        data: z.string().regex(/^0x[a-fA-F0-9]*$/),
                        chainId: z.number().gte(0)
                    }),
                    details: z.object({
                        blockNumber: z.coerce.bigint(),
                        relayer: z.string(),
                        simulationUrl: z.optional(z.string())
                    })
                })
            ]))
        })
    ])
});

export const zGetIntentOperationByIdData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        id: z.string().regex(/^\d+$/)
    }),
    query: z.optional(z.object({
        full: z.optional(z.boolean())
    })),
    headers: z.object({
        'x-api-key': z.string()
    })
});

/**
 * Successfully retrieved intent operation status
 */
export const zGetIntentOperationByIdResponse = z.object({
    status: z.enum([
        'PENDING',
        'PRECONFIRMED',
        'CLAIMED',
        'FILLED',
        'COMPLETED',
        'FAILED',
        'EXPIRED'
    ]),
    fillTimestamp: z.optional(z.number()),
    fillTransactionHash: z.optional(z.string()),
    claims: z.array(z.object({
        chainId: z.number(),
        status: z.enum([
            'PENDING',
            'EXPIRED',
            'PRECONFIRMED',
            'COMPLETED',
            'FAILED'
        ]),
        claimTimestamp: z.optional(z.number()),
        claimTransactionHash: z.optional(z.string())
    }))
});

export const zGetAccountsByUserAddressPortfolioData = z.object({
    body: z.optional(z.never()),
    path: z.object({
        userAddress: z.string()
    }),
    query: z.optional(z.object({
        chainIds: z.optional(z.string()),
        tokens: z.optional(z.string()),
        filterEmpty: z.optional(z.string()).default('false')
    })),
    headers: z.object({
        'x-api-key': z.string()
    })
});

/**
 * Successfully retrieved user portfolio
 */
export const zGetAccountsByUserAddressPortfolioResponse = z.object({
    portfolio: z.array(z.object({
        tokenName: z.string(),
        tokenDecimals: z.number().gte(0),
        balance: z.object({
            locked: z.coerce.bigint(),
            unlocked: z.coerce.bigint()
        }),
        tokenChainBalance: z.array(z.object({
            chainId: z.number().gte(0),
            tokenAddress: z.string(),
            balance: z.object({
                locked: z.coerce.bigint(),
                unlocked: z.coerce.bigint()
            })
        }))
    }))
});

export const zPostWithdrawalsData = z.object({
    body: z.optional(z.object({
        account: z.string(),
        chainId: z.number(),
        tokenAddress: z.string(),
        amount: z.coerce.bigint(),
        recipient: z.string()
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'x-api-key': z.string()
    })
});

/**
 * Successfully retrieved a compact signature
 */
export const zPostWithdrawalsResponse = z.object({
    allocatorData: z.string().regex(/^0x[a-fA-F0-9]*$/),
    transferDetails: z.object({
        id: z.coerce.bigint(),
        nonce: z.coerce.bigint(),
        expires: z.coerce.bigint(),
        recipients: z.array(z.object({
            claimant: z.coerce.bigint(),
            amount: z.coerce.bigint()
        }))
    })
});

export const zPostBatchWithdrawalsData = z.object({
    body: z.optional(z.object({
        account: z.string(),
        chainId: z.number(),
        transfers: z.array(z.object({
            recipient: z.string(),
            tokenAddress: z.string(),
            amount: z.coerce.bigint()
        }))
    })),
    path: z.optional(z.never()),
    query: z.optional(z.never()),
    headers: z.object({
        'x-api-key': z.string()
    })
});

/**
 * Successfully retrieved a compact batch withdrawal signature
 */
export const zPostBatchWithdrawalsResponse = z.object({
    allocatorData: z.string().regex(/^0x[a-fA-F0-9]*$/),
    batchTransferDetails: z.object({
        nonce: z.coerce.bigint(),
        expires: z.coerce.bigint(),
        transfers: z.array(z.object({
            id: z.coerce.bigint(),
            portions: z.array(z.object({
                claimant: z.coerce.bigint(),
                amount: z.coerce.bigint()
            }))
        }))
    })
});
